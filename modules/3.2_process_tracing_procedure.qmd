---
title: "Process Tracing with a Causal Model"
subtitle: "Procedure"
format: 
   revealjs:
      embed-resources: true
      theme: serif
      slide-level: 3
      slide-number: true
      toc-depth: 2
      show-slide-number: all
      preview-links: auto
      number-sections: true
      link-color: orange
      smaller: true
---

```{r, include = FALSE}
set.seed(1)
library(knitr)
library(CausalQueries)
source("assets/setup.R")
knitr::opts_chunk$set(echo = TRUE)
```


## General strategy 

*for process tracing with causal models*

* We can figure out from the causal model *which* causal types are consistent with our query
* We can figure out from the causal model *which* causal types are consistent with the data we observe
* If we have probabilities for each of these we can figure out the probability of the query given the data


## Key Bayesian insight


```{r}
#| label: fig-HJ-F-7-1
#| echo: false
#| fig-width: 6
#| fig-height: 6
#| fig-cap: "Logic of simple updating on arbitrary queries."
#| fig.align :  "center"
#| out.width :  "50%"

par(mar = c(.1,.1,.1,.1))
frame()
mycols <- c(
  rgb(0, 0, 255, max = 255, alpha = 125, names = "blue50"),
  rgb(255, 0, 0, max = 255, alpha = 125, names = "c2"),
  rgb(0, 255, 0, max = 255, alpha = 125, names = "c3"))

mycols <- c(NA, NA, NA)
plotrix::draw.circle(.35,.35,.3,nv=100,border=NULL,lty=1,density=NULL,
						angle=45,lwd=1, col = mycols[1])
plotrix::draw.circle(.65,.35,.3,nv=100,border=NULL,col=mycols[2],lty=1,density=NULL,
						angle=45,lwd=1)
plotrix::draw.circle(.5,.65,.3,nv=100,border=NULL,col=mycols[3],lty=1,density=NULL,
						angle=45,lwd=1)
text(.5, .8, "Types consistent\nwith query")
text(.2, .35, "Types consistent\nwith priors")
text(.8, .35, "Types consistent\nwith data")
text(.05, .95, expression(Theta))
text(.15, .95, "Universe of all\ncausal types")
text(.5, .45, "A")
text(.32, .55, "B")
text(.5, .25, "C")


box()
```





## By hand: Procedure

1. Make a table with rows for all causal types (there may be many if you are doing by hand!!)
2. Add  a column to indicate your priors over these causal type
3. Add a column to say if the query is satisfied by the causal types
4. Calculate the conditional distributions given the types


## By hand: Example

Our DAG is:

$$X \rightarrow M \rightarrow Y$$

And we believe:

* $X=1$ for half the cases, randomly
* $X$ has a positive effect on $M$ for half the cases ("causes"), in the other half $M=0$ regardless of $X$
* $M$ has a positive effect on $Y$ for half the cases, in the other half $Y=0$ regardless of $M$


## By hand: Example {.smaller}

What are the types? How likely is each one? How likely is each given the data?

* Which ones satisfy the following query: $Y = 0$ *because* $X=0$?:
* Which ones are consistent with data: $X = 0, Y = 0$

| Type                                                     | X | M | Y | prob | Query? | Data ? |
|----------------------------------------------------------|---|---|---|------|--------|--------|
| X = 0, X causes M, M causes Y                             | 0 | 0 | 0 | 1/8  | ✓      | ✓      |
| X = 0, X causes M, M does not cause Y                     | 0 | 0 | 0 | 1/8  |        | ✓      |
| X = 0, X does not cause M, M causes Y                     | 0 | 0 | 0 | 1/8  |        | ✓      |
| X = 0, X does not cause M, M does not cause Y             | 0 | 0 | 0 | 1/8  |        | ✓      |
| X = 1, X causes M, M causes Y                             | 1 | 1 | 1 | 1/8  |        |        |
| X = 1, X causes M, M does not cause Y                     | 1 | 1 | 0 | 1/8  |        |        |
| X = 1, X does not cause M, M causes Y                     | 1 | 0 | 0 | 1/8  |        |        |
| X = 1, X does not cause M, M does not cause Y             | 1 | 0 | 0 | 1/8  |        |        |


## With `CausalQueries`: Step 1

Define a model

```{r, echo = TRUE}

model <- 
  make_model("X -> M -> Y") |>
  set_restrictions("M[X = 0] == 1") |>
  set_restrictions("Y[M = 0] == 1")

query <- "Y[X=1] > Y[X=0]"
```

## With `CausalQueries`: Step 2

Get types consistent with query

```{r}
get_query_types(model, query)

```

## With `CausalQueries`: Step 3


Get mapping from causal types to consistent data types

```{r}
inspect(model, what = "ambiguities_matrix") 
```

## With `CausalQueries`: Step 4

Get prior probabilities of each causal type

```{r}
CausalQueries:::get_type_prob(model)

```

## Put it all together

```{r}
model  |>
  grab(what = "ambiguities_matrix") |>
  data.frame() |>
  mutate(
    in_query = get_query_types(model, query)$types,
    priors   = CausalQueries:::get_type_prob(model)) |>
  kable()
```

## In one go with `CausalQueries`

```{r, echo = TRUE}
query_model(model, query, given = c("X==0 & M ==0 & Y == 0"))
```


## Three clues example

Three clues for figuring out the effect of $X$ on $Y$

```{r, echo = FALSE}
model <- make_model("X -> K1 -> Y <- K2; Y -> K3; Y <-> K3") 
model |> plot(x_coord = c(2,1,2,3,4), y_coord = c(2, 1, 1, 1, 0))
```


## Three clues example

Three clues for figuring out the effect of $X$ on $Y$

```{r} 
observed = c("Y==1 & X==1",
           "Y==1 & X==1 & K1==1",
           "Y==1 & X==1 & K2==1",
           "Y==1 & X==1 & K3==1",
           "Y==1 & X==1 & K1==1 & K2==1 & K3==1")

query_model(model = model, 
            query = "Y[X=1] > Y[X=0]",
            given = observed)
```

## With information

```{r}
model |>
  set_restrictions(decreasing("X", "K1")) |>
  set_restrictions(decreasing("K1", "Y")) |>
  set_restrictions(decreasing("K2", "Y")) |>
  set_restrictions(decreasing("Y", "K3")) |>
  set_parameters(given = "Y.0001", nodal_type = "11", .9)|>
  query_model(
    query = "Y[X=1] > Y[X=0]",
    given = observed)

```

## In one go with `CausalQueries`

Also try our [shiny app](https://shiny2.wzb.eu/ipi/process_tracing/)

```{r, echo = FALSE, fig.align = "center", eval = TRUE}
knitr::include_graphics("assets/shiny.jpg")
```

## Process tracing with causal models

Key advantages of using a causal model:

* Makes clear how process tracing is always theory-dependent
* Provides a way of systematically integrating background knowledge (theory) into inference
* Makes highly explicit/transparent how we get from evidence to conclusions
* Enhances evaluability of findings
    * If I have different background beliefs from you, I can work out how my conclusions from same evidence would be different


